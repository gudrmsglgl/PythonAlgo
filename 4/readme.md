# 빅오, 자료형

[빅오](#id-section1)<br>
[상한과 최악](#id-section2)<br>

- 컴퓨터과학에서 빅오는 입력값이 커질 때 <br>
  알고리즘의 실행 시간(시간 복잡도)과 함께 공간 요구사항(공간 복잡도)이 <br>
  어떻게 증가하는지를 분류하는 데 사용되며, <br>
  알고리즘의 효율성 분석 매우 유용
  
- 시간 복잡도를 분석할 때 '상한'과 '최악'의 경우에 대해 혼동하는 부분 체크
- 함수의 동작을 설명하는 매우 중요한 방법 중 하나인 <br>
  **분할 상환 분석**에 대해서도 체크
  
- 파이썬의 어떤 자료형을 제공하는지, 자료형의 특징 체크.

<br>
<div id='id-section1'/>

## 빅오
> 빅오(O, big-O)란 입력값이 무한대로 향할 때 함수의 상한을 <br> 
> 설명하는 수학적 표기 방법이다.

- 먼저, 빅오는 점근적 실행 시간 (Asymptotic Running Time)를 표기할 때 가장 널리 쓰이는 수학적 표기법 중 하나.
- 점근적 실행 시간이란
    - 입력값 n이 커질 때, 즉 입력값이 무한대를 향할 때 함수의 실행 시간의 추이를 의미.
    
- 알고리즘은 궁극적으로는 컴퓨터로 구현되므로, 컴퓨터의 빠른 처리 능력을 감안하면 아무리 복잡한 알고리즘도 입력의 크기가 작으면 금방 끝나버린다.
- 그러므로 관심의 대상이 되는 것은 입력의 크기가 충분히 클 때다.
- 충분히 큰 입력에서는 알고리즘의 효율성에 따라 수행 시간이 크게 차이가 날 수 있다.
- n이 작다면 *O(n)* 의 시간이 걸리는 온라인 전송이 빠르다.
- 하지만 파일이 아주 크다면 비행기를 통해 물리적으로 배달하는게 더 빠를 수 있다.
- 파일이 아무리 커도, 즉 n이 아무리 커도 비행기를 통한 파일 전송은 *O(1)* 로 항상 일정한 시간이 소요.
- 이것이 바로 점근적 실행 시간이며, 빅오는 점근적 실행 시간을 표기하는 방법 중 하나.
- **점근적 실행 시간**은 달리 말하면 *시간 복잡도*라 할 수 있다.
- 시간 복잡도 (Time Complexity)
  - 어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도를 의미
  - 🚀 **계산 복잡도를 표기하는 대표적인 방법이 바로 빅오다.**
  - 빅오
    - [x] 최고차항만을 표기하며, 계수는 무시한다. (4n^2 + 3n + 4) -> 계수는 무시 -> n^2 만을 고려
    - [x] 여기서 시간 복잡도는 _O(n^2)_
    - [x] 이처럼 시간 복잡도를 표기할 때는 입력값에 따른 알고리즘의 실행 시간의 추이만을 살피게 된다.
    - [x] _O(1)_  
        > 입력값이 아무리 커도 실행 시간은 일정하다. <br>
        👍🏻 최고의 알고리즘 <br>
        🔎 O(1)에 실행되는 알고리즘으로 해시 테이블의 조회 및 삽입이 이에 해당
    - [x] _O(logn)_  
        > 여기서부터 실행 시간은 입력값에 영향을 받는다. <br>
        👌🏻 그러나 로그는 매우 큰 입력값에도 크게 영향을 받지 않는 편으로 웬만한 n의 크기에 대해서 매우 견고 <br>
        🔎 대표적으로 이진 검색이 이에 해당   
    - [x] _O(n)_  
        > 입력값만큼 실행 시간에 영향을 받으며, 알고리즘을 수행하는 데 걸리는 시간은 입력값에 비례한다. <br>
        이러한 알고리즘을 선형 시간 (Linear-Time) 알고리즘이라고 한다. <br>
        🔎 정렬되지 않는 리스트에서 최댓값 또는 최솟값을 찾는 경우가 이에 해당되며 <br>
            이 값을 찾기 위해서는 모든 입력값을 적어도 한 번 이상은 살펴야함 
    - [x] _O(nlogn)_  
        > 병합 정렬을 비롯한 대부분의 효율 좋은 정렬 알고리즘이 이에 해당. <br>
        적어도 모든 수에 대해 한 번 이상 비교해야 하는 비교 기반 정렬 알고리즘은 <br>
        아무리 좋은 알고리즘도 O(n log n)보다 빠를 수 없다. <br>
        🔎 물론 입력값이 최선인 경우, 비교를 건너뛰어 O(n)이 될 수 있으며 팀소트 Timsort가 이런 로직.
    - [x] _O(n^2)_  
        > 🔎 버블 정렬 같은 비효율적인 정렬 알고리즘이 이에 해당.
    - [x] _O(2^n)_  
        > 🔎 피보나치 수를 재귀로 계산하는 알고리즘이 이에 해당 <br>
         간혹 n^2 과 혼동하는 경우가 있는데 처음에는 비슷해 보이지만 2^n이 훨씬 크다. <br>
    - [x] _O(n!)_  
        > 🔎 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 외판원 문제 Travelling Salesman Problem(TSP) <br>
             가장 느린 알고리즘으로, 입력값이 조금만 커져도 웬만한 다항 시간 내에는 계산이 어렵다. <br>
       
- 빅오는 시간 복잡도 외에도 공간 복잡도를 표현하는 데에도 널리 쓰인다.
- 또한 알고리즘은 흔히 '시간과 공간이 트레이드오프 Space-Time Tradeoff' 관계다.
- 이 말은 실행 시간이 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행 시간이 느리다.

<br>
<div id='id-section2'/>

## 상한과 최악
- 빅오(_O_)는 상한 Upper Bound을 의미한다.
- 이외에도 하한 Lower Bound을 나타내는 빅오메가 (_Ω_), 평균을 의미하는 빅세타 (_θ_)
- 학계와 달리 업계에서는 빅세타와 빅오를 하나로 합쳐서 단순화해서 표현하려는 경향이 있다.
- 평균적인 시간보다는 상한 시간으로 단순화해서 주로 표현
- 매번 구분하는 것이 번거롭고 혼동되기도 하며 또한 상한으로만 표현하는 방법이 틀리지 않기 때문.
- **🤔 상한을 최악의 경우와 혼동하는 것**
  - 빅오 표기법은 정확하게 쓰기에는 너무 길고 복잡한 함수를 **'적당히 정확하게'** 표현하는 방법일 뿐
  - 최악의 경우/평균적인 경우의 시간 복잡도와는 아무런 관계가 없는 개념이라는 점에 유의.
  - 빅오 표기는 복잡한 함수 _f(n)_ 이 있을 경우, 이 함수의 실행 상한과 하한을 의미.
  - 즉 가장 빨리 실행될 때(하한), 가장 빨리 실행될 때를 빅오메가(_Ω_), 평균적으로는 빅세타(_θ_)로 지칭.
  - n이 작을 때, 즉 n0 이하일 때의 값이 작은 경우는 무시하며, 빅오 표기법은 n이 매우 클 때의 전체적인 큰 그림에 집중한다.
  
> 빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타낸다.