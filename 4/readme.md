# 빅오, 자료형

[빅오](#id-section1)<br>
[상한과 최악](#id-section2)<br>
[분할 상환 분석](#id-section3)<br>
[병렬화](#id-section4)<br>



- 컴퓨터과학에서 빅오는 입력값이 커질 때 <br>
  알고리즘의 실행 시간(시간 복잡도)과 함께 공간 요구사항(공간 복잡도)이 <br>
  어떻게 증가하는지를 분류하는 데 사용되며, <br>
  알고리즘의 효율성 분석 매우 유용
  
- 시간 복잡도를 분석할 때 '상한'과 '최악'의 경우에 대해 혼동하는 부분 체크
- 함수의 동작을 설명하는 매우 중요한 방법 중 하나인 <br>
  **분할 상환 분석**에 대해서도 체크
  
- 파이썬의 어떤 자료형을 제공하는지, 자료형의 특징 체크.

<br>
<div id='id-section1'/>

## 빅오
> 빅오(O, big-O)란 입력값이 무한대로 향할 때 함수의 상한을 <br> 
> 설명하는 수학적 표기 방법이다.

- 먼저, 빅오는 점근적 실행 시간 (Asymptotic Running Time)를 표기할 때 가장 널리 쓰이는 수학적 표기법 중 하나.
- 점근적 실행 시간이란
    - 입력값 n이 커질 때, 즉 입력값이 무한대를 향할 때 함수의 실행 시간의 추이를 의미.
    
- 알고리즘은 궁극적으로는 컴퓨터로 구현되므로, 컴퓨터의 빠른 처리 능력을 감안하면 아무리 복잡한 알고리즘도 입력의 크기가 작으면 금방 끝나버린다.
- 그러므로 관심의 대상이 되는 것은 입력의 크기가 충분히 클 때다.
- 충분히 큰 입력에서는 알고리즘의 효율성에 따라 수행 시간이 크게 차이가 날 수 있다.
- n이 작다면 *O(n)* 의 시간이 걸리는 온라인 전송이 빠르다.
- 하지만 파일이 아주 크다면 비행기를 통해 물리적으로 배달하는게 더 빠를 수 있다.
- 파일이 아무리 커도, 즉 n이 아무리 커도 비행기를 통한 파일 전송은 *O(1)* 로 항상 일정한 시간이 소요.
- 이것이 바로 점근적 실행 시간이며, 빅오는 점근적 실행 시간을 표기하는 방법 중 하나.
- **점근적 실행 시간**은 달리 말하면 *시간 복잡도*라 할 수 있다.
- 시간 복잡도 (Time Complexity)
  - 어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도를 의미
  - 🚀 **계산 복잡도를 표기하는 대표적인 방법이 바로 빅오다.**
  - 빅오
    - [x] 최고차항만을 표기하며, 계수는 무시한다. (4n^2 + 3n + 4) -> 계수는 무시 -> n^2 만을 고려
    - [x] 여기서 시간 복잡도는 _O(n^2)_
    - [x] 이처럼 시간 복잡도를 표기할 때는 입력값에 따른 알고리즘의 실행 시간의 추이만을 살피게 된다.
    - [x] _O(1)_  
        > 입력값이 아무리 커도 실행 시간은 일정하다. <br>
        👍🏻 최고의 알고리즘 <br>
        🔎 O(1)에 실행되는 알고리즘으로 해시 테이블의 조회 및 삽입이 이에 해당
    - [x] _O(logn)_  
        > 여기서부터 실행 시간은 입력값에 영향을 받는다. <br>
        👌🏻 그러나 로그는 매우 큰 입력값에도 크게 영향을 받지 않는 편으로 웬만한 n의 크기에 대해서 매우 견고 <br>
        🔎 대표적으로 이진 검색이 이에 해당   
    - [x] _O(n)_  
        > 입력값만큼 실행 시간에 영향을 받으며, 알고리즘을 수행하는 데 걸리는 시간은 입력값에 비례한다. <br>
        이러한 알고리즘을 선형 시간 (Linear-Time) 알고리즘이라고 한다. <br>
        🔎 정렬되지 않는 리스트에서 최댓값 또는 최솟값을 찾는 경우가 이에 해당되며 <br>
            이 값을 찾기 위해서는 모든 입력값을 적어도 한 번 이상은 살펴야함 
    - [x] _O(nlogn)_  
        > 병합 정렬을 비롯한 대부분의 효율 좋은 정렬 알고리즘이 이에 해당. <br>
        적어도 모든 수에 대해 한 번 이상 비교해야 하는 비교 기반 정렬 알고리즘은 <br>
        아무리 좋은 알고리즘도 O(n log n)보다 빠를 수 없다. <br>
        🔎 물론 입력값이 최선인 경우, 비교를 건너뛰어 O(n)이 될 수 있으며 팀소트 Timsort가 이런 로직.
    - [x] _O(n^2)_  
        > 🔎 버블 정렬 같은 비효율적인 정렬 알고리즘이 이에 해당.
    - [x] _O(2^n)_  
        > 🔎 피보나치 수를 재귀로 계산하는 알고리즘이 이에 해당 <br>
         간혹 n^2 과 혼동하는 경우가 있는데 처음에는 비슷해 보이지만 2^n이 훨씬 크다. <br>
    - [x] _O(n!)_  
        > 🔎 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 외판원 문제 Travelling Salesman Problem(TSP) <br>
             가장 느린 알고리즘으로, 입력값이 조금만 커져도 웬만한 다항 시간 내에는 계산이 어렵다. <br>
       
- 빅오는 시간 복잡도 외에도 공간 복잡도를 표현하는 데에도 널리 쓰인다.
- 또한 알고리즘은 흔히 '시간과 공간이 트레이드오프 Space-Time Tradeoff' 관계다.
- 이 말은 실행 시간이 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행 시간이 느리다.

<br>
<div id='id-section2'/>

## 상한과 최악
- 빅오(_O_)는 상한 Upper Bound을 의미한다.
- 이외에도 하한 Lower Bound을 나타내는 빅오메가 (_Ω_), 평균을 의미하는 빅세타 (_θ_)
- 학계와 달리 업계에서는 빅세타와 빅오를 하나로 합쳐서 단순화해서 표현하려는 경향이 있다.
- 평균적인 시간보다는 상한 시간으로 단순화해서 주로 표현
- 매번 구분하는 것이 번거롭고 혼동되기도 하며 또한 상한으로만 표현하는 방법이 틀리지 않기 때문.
- **🤔 상한을 최악의 경우와 혼동하는 것**
  - 빅오 표기법은 정확하게 쓰기에는 너무 길고 복잡한 함수를 **'적당히 정확하게'** 표현하는 방법일 뿐
  - 최악의 경우/평균적인 경우의 시간 복잡도와는 아무런 관계가 없는 개념이라는 점에 유의.
  - 빅오 표기는 복잡한 함수 _f(n)_ 이 있을 경우, 이 함수의 실행 상한과 하한을 의미.
  - 즉 가장 빨리 실행될 때(하한), 가장 빨리 실행될 때를 빅오메가(_Ω_), 평균적으로는 빅세타(_θ_)로 지칭.
  - n이 작을 때, 즉 n0 이하일 때의 값이 작은 경우는 무시하며, 빅오 표기법은 n이 매우 클 때의 전체적인 큰 그림에 집중한다.
  
> 빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타낸다.
 
<br>
<div id='id-section3'/>

## 분할 상환 분석
> 시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때, 알고리즘 전체를<br>
> 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적이라는 이유로<br>
> 분할 상환 분석 방법이 등장하는 계기가 됐다.
- 분할 상환 분석 Amortized Analysis은 빅오와 함께 함수의 동작을 설명할 때 중요한 분석 방법 중 하나.
- 대표적인 예로 **'동적 배열'**
- 동적 배열에서 더블링이 일어나는 일은 어쩌다 한 번뿐이지만, <br>
  이로 인해 '아이템 삽입 시 시간 복잡도는 _O(n)_ 이다.' 라고 얘기하는 건 지나치게 비관적이고 정확하지 않다.
  
- 따라서 이 경우 **'분할 상환'** 또는 **'상각'** 이라고 표현하는 <br>
  **최악의 경우를 여러 번에 걸쳐 골고루 나눠**주는 형태로 <br>
  알고리즘의 시간 복잡도를 계산할 수 있다.
  
- 이렇게 할 경우 동적 배열의 삽입 시 시간 복잡도는 _O(1)_이 된다.

<br>
<div id='id-section4'/>

## 병렬화
- 일부 알고리즘들은 병렬화로 실행 속도를 높일 수 있다.
- 최근에는 딥러닝의 인기와 함께 병렬화가 큰 주목을 받고 있으며 GPU는 병렬 연산을 위한 대표적인 장치.
- GPU 각각의 코어는 CPU 보다 훨씬 더 느리지만 GPU의 코어는 수천여 개로 구성되어 있어,
- 많아 봐야 수십여 개에 불과한 CPU보다 수백 배 더 많은 연산을 동시에 수행할 수 있다.
- 예를 들어 CPU가 비행기로 짐을 여러 번 나르는 것이라면, GPU는 배로 수많은 짐을 한 번에 나르는 것에 비유할 수 있다.
- 각 배의 운반 속도는 훨씬 느리지만 비행기보다 더 많은 짐을 동시에 나를 수 있는 것처럼
- GPU는 결국 같은 시간에 목적지에 훨씬 더 많은 짐을 나를 수 있다.
- 이처럼 딥러닝 알고리즘을 비롯해 병렬 연산이 가능한 알고리즘들은 최근에 큰 주목을 받고 있다.
- 알고리즘 자체의 시간 복잡도 외에도 알고리즘이 병렬화가 가능한지는
- 근래에 알고리즘의 우수성을 평가하는 매우 중요한 척도 중 하나.
